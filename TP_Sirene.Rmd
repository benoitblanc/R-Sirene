---
title: "TP_Sirene"
author: "Beno√Æt Blanc"
date: "10/10/2019"
output:
  pdf_document: 
    latex_engine: xelatex
  html_document: default
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60),  # For code
                      width = 60)  # For output
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

# Mise en place

```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow.png")
```

## Installations, t√©l√©chargements, premiers tests sur le d√©partement 42
T√©l√©chargez les donn√©es du d√©partement 42, geo_siret_42.csv dans ce r√©pertoire et d√©zippez le dossier sur votre machine.

T√©l√©chargez la table qui renseigne les codes correspondant √† l‚ÄôActivit√© Principale de l‚ÄôEtablissement (APE)APE_Type.csv

```{r}
library(dplyr)
library(readr)
```

## Lecture de tableaux de donn√©es
Depuis RStudio, cr√©ez un projet qui comprendra l‚Äôensemble des donn√©es et documents n√©cessaires √† r√©aliser l‚Äôensemble des traitements qui vous seront demand√©s pour ce TP.

Cr√©ez le data.frame data42 en lisant la table geo-siret_42.csv.
```{r, include=TRUE}
data42 <- read.csv("data/geo_siret_42.csv", header = TRUE)
```
Cr√©ez l‚Äôobjet APE_Type en lisant le fichier relatif aux codes d‚ÄôAPE.
```{r, include=TRUE}
APE_Type <- read.csv("data/APE_Type.csv", header = TRUE)
```

## Code et types d‚Äôactivit√©s => commerces alimentaires
```{r}
library(stringr)
```
Combien d‚Äôentreprises ont un nom (enseigne1Etablissement) qui comprend le terme ‚ÄúBOULANGERIE‚Äù?
```{r}
boulangeries <- filter(data42, str_detect(enseigne1Etablissement, "BOULANGERIE"))
```
Il y a `r summarise(boulangeries, n())` entreprises qui comprennent le terme "BOULANGERIE" dans leur nom.

Ajoutez une variable Code √† votre table en ne conservant que les quatre premiers caract√®res de la variable activitePrincipaleEtablissement (cela correspond √† un pattern ‚Äú^‚Ä¶.‚Äù, √† savoir le d√©but de cha√Æne de caract√®re suivi de quatre caract√®res quelconques -cf ce billet de blog sur les expressions r√©guli√®res-).

```{r}
data42 <- mutate(data42, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
```

Filtrez les lignes de data42 pour ne retenir que celles pour lesquelles l‚ÄôAPE correspond aux commerces ‚Äúalimentaires‚Äù -alimentation, boisson, restaurant, bar- (voir la liste contenue dans le fichier APE_Type).

Stockez le r√©sultat de ces op√©rations dans un objet alim42.

```{r, echo=FALSE, include=FALSE}
print(APE_Type)
```

```{r}
alim42 <- filter(data42, Code=="47.1" | Code=="47.2" | Code=="56.1" | Code=="56.2" | Code=="56.3")
```

R√©alisez une jointure entre data42_alim (variable codeAPE) et APE_Type (variable Code), de mani√®re √† compl√©ter alim42 avec les types de commerces (variables Type et TypeAbreg).

```{r}
alim42 <- left_join(alim42, APE_Type, by="Code")
```

## R√©sum√©, classement
Quelles sont les 3 communes de votre base de donn√©es qui comptent le plus de magasins alimentaires?

```{r, include=FALSE}
alim42 %>% 
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim))
```
Les trois communes comptant le plus de commerces alimentaires sont 
```{r}
alim42 %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim)) %>%
  head(3)
```

Pour les communes qui ne comptent qu‚Äôun seul commerce ‚Äúalimentaire‚Äù, de quel type est-il, le plus fr√©quemment?
```{r}
onlyonecommerce <- group_by(alim42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  filter(nb_commerces_alim==1)
```

Les communes ne comptant qu'un seul commerce "alimentaire" sont au nombre de `r length(onlyonecommerce$codeCommuneEtablissement)`. Avec en d√©tail :
`r onlyonecommerce$libelleCommuneEtablissement`

```{r}
typeonecommerce <- filter(alim42, codeCommuneEtablissement 
                          %in% onlyonecommerce$codeCommuneEtablissement) %>%
  group_by(Type) %>%
  summarise(nb_types=n()) %>%
  arrange(desc(nb_types)) %>%
  filter(nb_types == max(nb_types))
```
Lorsqu'il y a un seul commerce alimentaire dans une commune, celui-ci est de type `r typeonecommerce$Type`.

Quelles communes de plus de 100 commerces comptent au moins 10 commerces de type ‚Äúviande‚Äù?
```{r}
data42 <- inner_join(data42, APE_Type, by="Code")
```

```{r}
morethan100commerces <- group_by(data42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces=n())
morethan100commerces <- filter(morethan100commerces, nb_commerces>=100)
```

Les communes de plus de 100 commerces sont `r morethan100commerces$libelleCommuneEtablissement`

```{r}
morethan10viandes <- filter(data42, TypeAbreg=='viande') %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_viande=n())
morethan10viandes <- filter(morethan10viandes, nb_commerces_viande>=10)
```

Les communes qui ont plus de 10 commerces de type 'viande' sont `r morethan10viandes$libelleCommuneEtablissement`

On retrouve les `r length(morethan10viandes$codeCommuneEtablissement)` communes ayant plus de 10 commerces de type 'viande' dans les villes ayant plus de 100 commerces. On a donc la r√©ponse. Mais pour s'assurer, on peut r√©aliser une jointure entre les 2 tableaux :

```{r}
more100commerces10viandes <- left_join(morethan10viandes, morethan100commerces, 
                                       by=c("codeCommuneEtablissement", "libelleCommuneEtablissement"))
```

On retrouve le m√™me r√©sultat : `r more100commerces10viandes$libelleCommuneEtablissement`

# Rapport, statistiques descriptives
A ce stade, votre script commence √† √™tre un peu long et (peut-√™tre) un peu d√©sordonn√©‚Ä¶ Ne serait-ce pas plus agr√©able de continuer votre projet sous la forme d‚Äôun rapport Rmarkdown? (Ne r√©pondez pas √† cette question, elle est rh√©torique‚Ä¶).

Cr√©ez un document ____.Rmd, structurez-le avec quelques titres, et r√©partissez les diff√©rents morceaux de code de votre script de mani√®re pertinente dans diff√©rents chunks.
Vous pouvez maintenant r√©diger des paragraphes en y int√©grant des √©l√©ments de r√©ponses aux questions pos√©es pr√©c√©demment. R√©digez un petit paragraphe pour nommer les 3 communes qui comptent le plus d‚Äôentreprises (exercice pr√©c√©dent) en utilisant l‚Äôinsertion d‚Äô‚Äúinline chunks‚Äù.
A partir de maintenant, votre document de travail sera un document`___.Rmd‚Äô et non le script que vous avez cr√©√© initialement‚Ä¶

# Programmation: automatisation pour plusieurs d√©partements
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_prog.png")
```

## Fonction
Pour obtenir la table alim42, vous avez r√©alis√© un certain nombre d‚Äôop√©rations. On voudrait r√©aliser l‚Äôensemble de ces op√©rations pour les 5 d√©partements suivants:

- l‚ÄôAin (01)
- l‚ÄôIs√®re (38)
- la Loire (42)
- la Haute-Loire (43)
- le Rh√¥ne (69)

R√©utilisez les commandes que vous avez mises au point sur data42 pour √©crire une fonction get_clean_data() qui r√©alisera l‚Äôensemble de ces op√©rations sur le d√©partement de votre choix. L‚Äôinput correspondra √† un num√©ro de d√©partement (c‚Äôest-√†-dire que vous pourrez utiliser la fonction en faisant, par exemple get_clean_data("01")).

üí≠ Pour lire le fichier, il faudra indiquer son chemin‚Ä¶ Pensez √† r√©utiliser ce que vous venez d‚Äôapprendre sur les cha√Ænes de caract√®res pour reformer le chemin du fichier que vous int√©resse √† partir du num√©ro de d√©partement‚Ä¶

Certaines cha√Ænes de caract√®re sont interpr√©t√©es comme des cha√Ænes de caract√®re pour certains jeux de donn√©es (par exemple pour les codes postaux de l‚ÄôAin, √† cause du ‚Äú0‚Äù en d√©but de cha√Æne) tandis qu‚Äôelle est interpr√©t√©e comme un num√©rique pour les autres jeux de donn√©es. Faites en sorte que votre fonction transforme bien cette variable pour qu‚Äôelles soient toujours de classe ‚Äúcharacter‚Äù en sortie (conversion par as.character()‚Ä¶).

```{r}
library(purrr)
```

```{r}
get_clean_data <- function(dept) {
  dept <- as.character(dept)
  print(dept)
  # Read CSV file for dept
  filename <- "data/geo_siret_XX.csv"
  filename <- str_replace(filename, "X{2}", dept)
  print(filename)
  data <- read.csv(filename, header = TRUE)
  data <- mutate(data, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
  alim <- filter(data, Code=="47.1" | Code=="47.2" | Code=="56.1" | Code=="56.2" | Code=="56.3")
  alim <- left_join(alim, APE_Type, by="Code")
  
  return(alim)
}
```

## It√©ration

Appelez cette fonction de mani√®re it√©rative pour chacun des d√©partements cit√©s ci-dessus. Vous pouvez pour ce faire soit √©crire une boucle for, soit utiliser la fonction map() du package purrr.

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  departements <- list("01", "38", "42", "43", "69")
  commercesRA <- map(departements, get_clean_data)  
} else {
  alimRA_entr <- read.csv("data/alimRA_entr.csv", header = TRUE)
}
```

A partir des 5 jeux de donn√©es obtenus vous cr√©erez un seul et m√™me jeu de donn√©es alimRA_entr (donn√©es pour l‚Äôancienne r√©gion Rh√¥ne-Alpes, o√π 1 ligne=1 entreprise).

üóØ Vous pourrez si vous le souhaitez vous servir de la commande do.call("rbind",...) ou bind_rows().

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  #alimRA_entr <- bind_rows(commercesRA)
  alimRA_entr <- do.call("rbind", commercesRA)
}
```

Rajoutez une variable departement (correspondant au num√©ro de d√©partement) √† votre jeu de donn√©es alimRA_entr. Peut-√™tre par des manipulations sur le code postal?‚Ä¶

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  alimRA_entr <- mutate(alimRA_entr, codePostalEtablissement= as.character(codePostalEtablissement))
  alimRA_entr <- mutate(alimRA_entr, codePostalEtablissement=gsub("^([0-9]{1,4})", "0\\1", as.character(codePostalEtablissement)))
  alimRA_entr <- mutate(alimRA_entr, departement=str_extract(codePostalEtablissement, "^.{2}"))
}
```

## If et √©criture de fichier

Vous avez d√ª remarquer que l‚Äôex√©cution de l‚Äô√©tape pr√©c√©dente prenait un peu de temps car les 5 fichiers geo-sirene lus sont tr√®s volumineux‚Ä¶ En revanche la table alimRA_entr est de taille beaucoup plus raisonnable. Or, nous n‚Äôaurons besoin que de cette table pour la suite du projet. Pour √©viter d‚Äôex√©cuter cette √©tape chronophage √† chaque fois que vous travaillerez sur ce projet:

- exportez alimRA_entr dans un fichier alimRA_entr.csv.
- entourez la boucle for d‚Äôune structure conditionnelle if de sorte que la boucle ne soit ex√©cut√©e que si le fichier alimRA_entr.csv n‚Äôexiste pas (voir fonction file.exists()‚Ä¶)
- √©crivez √† la suite la commande qui servira √† lire alimRA_entr.csv √† chaque ‚Äútricotage‚Äù de votre rapport Rmarkdown.

```{r}
write.csv(alimRA_entr, "data/alimRA_entr.csv", row.names = FALSE, quote = TRUE)
alimRA_entr <- read.csv("data/alimRA_entr.csv", header = TRUE)
```

# R√©sum√© par commune et type de commerce
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_resume.png")
```

## Agr√©gation des donn√©es par commune et type de commerce
Agr√©gez la table alimRA_entr par commune et type de commerce, pour cr√©er une table alimRA_typeCom (o√π une ligne correspondra √† un type de commerce pour une commune):

```{r eval=FALSE, include=FALSE}
get_nb_commerces_by_commune <- function(df) {
  df <- group_by(df, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
    summarise(nb_commerces=n())
  return(df$nb_commerces)
}
get_nb_commerces_by_type_by_commune <- function(df) {
  
  
  return(alim)
}
get_proportion_type_in_commune {
<- function(df)   
}return(0)
```

```{r}
alimRA_Com <- group_by(alimRA_entr, codeCommuneEtablissement, libelleCommuneEtablissement)%>%
  summarise(nInCom=n())
alimRA_type <- group_by(alimRA_entr, codeCommuneEtablissement, libelleCommuneEtablissement, TypeAbreg)%>%
  summarise(nInTypeCom=n()) %>%
  mutate(propInTypeCom = round(nInTypeCom / sum(nInTypeCom)*100))
```

- une variable nInCom correspondant au nombre de commerces par commune
- une variable nInTypeCom correspondant au nombre de commerces par type et commune
- une variable propInTypeCom correspondant √† la proportion d‚Äôun type de commerce dans une commune

```{r}
alimRA_typeCom <- left_join(alimRA_Com, alimRA_type, 
                                       by=c("codeCommuneEtablissement", "libelleCommuneEtablissement"))
```

Quelles communes comptant plus de 100 commerces comptent au moins 15% de commerces de type ‚Äúbar‚Äù?
```{r}
communes_15pct_bar <- filter(alimRA_typeCom, TypeAbreg=='bar' & nInCom >= 100 & propInTypeCom >= 15)
```

Les communes comptant plus de 100 commerces, dont les commerces de type 'bar' repr√©sentent au moins 15% sont `r communes_15pct_bar$libelleCommuneEtablissement`