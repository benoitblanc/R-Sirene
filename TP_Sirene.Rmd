---
title: "TP_Sirene"
author: "Beno√Æt Blanc"
date: "10/10/2019"
output:
  pdf_document: 
    latex_engine: xelatex
  html_document: default
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60),  # For code
                      width = 60)  # For output
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

# Mise en place

```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow.png")
```

## Installations, t√©l√©chargements, premiers tests sur le d√©partement 42
T√©l√©chargez les donn√©es du d√©partement 42, geo_siret_42.csv dans ce r√©pertoire et d√©zippez le dossier sur votre machine.

T√©l√©chargez la table qui renseigne les codes correspondant √† l‚ÄôActivit√© Principale de l‚ÄôEtablissement (APE)APE_Type.csv

```{r}
library(dplyr)
library(readr)
```

## Lecture de tableaux de donn√©es
Depuis RStudio, cr√©ez un projet qui comprendra l‚Äôensemble des donn√©es et documents n√©cessaires √† r√©aliser l‚Äôensemble des traitements qui vous seront demand√©s pour ce TP.

Cr√©ez le data.frame data42 en lisant la table geo-siret_42.csv.
```{r warning=FALSE, include=TRUE}
data42 <- read_csv("data/geo_siret_42.csv")
```
Cr√©ez l‚Äôobjet APE_Type en lisant le fichier relatif aux codes d‚ÄôAPE.
```{r, include=TRUE}
APE_Type <- read_csv("data/APE_Type.csv")
```

## Code et types d‚Äôactivit√©s => commerces alimentaires
```{r}
library(stringr)
```
Combien d‚Äôentreprises ont un nom (enseigne1Etablissement) qui comprend le terme ‚ÄúBOULANGERIE‚Äù?
```{r include=FALSE}
boulangeries <- filter(data42, str_detect(enseigne1Etablissement, "BOULANGERIE"))
```
Il y a `r summarise(boulangeries, n())` entreprises qui comprennent le terme "BOULANGERIE" dans leur nom.

Ajoutez une variable Code √† votre table en ne conservant que les quatre premiers caract√®res de la variable activitePrincipaleEtablissement (cela correspond √† un pattern ‚Äú^‚Ä¶.‚Äù, √† savoir le d√©but de cha√Æne de caract√®re suivi de quatre caract√®res quelconques -cf ce billet de blog sur les expressions r√©guli√®res-).

```{r}
data42 <- mutate(data42, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
```

Filtrez les lignes de data42 pour ne retenir que celles pour lesquelles l‚ÄôAPE correspond aux commerces ‚Äúalimentaires‚Äù -alimentation, boisson, restaurant, bar- (voir la liste contenue dans le fichier APE_Type).

Stockez le r√©sultat de ces op√©rations dans un objet alim42.

```{r, echo=FALSE, include=FALSE}
print(APE_Type)
```

```{r}
code_alim <- c("10.1", "10.2", "10.3", "10.5", "10.7", "10.8", "11.0", "47.1", "47.2", "56.1", "56.2", "56.3")
alim42 <- filter(data42, Code %in% code_alim)
```

R√©alisez une jointure entre data42_alim (variable codeAPE) et APE_Type (variable Code), de mani√®re √† compl√©ter alim42 avec les types de commerces (variables Type et TypeAbreg).

```{r}
alim42 <- left_join(alim42, APE_Type, by="Code")
```

## R√©sum√©, classement

On cr√©e une fonction pour charger le SHP d'un d√©partement pour visualiser les prochains r√©sultats sur une carte
```{r}
library(ggplot2)
library(sf)
load_SHP_dept <- function(dept) {
  filename <- "data/GEOFLA_XX.shp"
  filename <- str_replace(filename, "X{2}", dept)
  dept_shp <- st_read(filename,
                      stringsAsFactors = FALSE)
  st_crs(dept_shp)<-2154  # on d√©finit la projection Lambert93
  return(dept_shp)
}
```

On charge le SHP de la Loire
```{r}
dept42_SHP <- load_SHP_dept("42")
plot(dept42_SHP$geometry)
```

Quelles sont les 3 communes de votre base de donn√©es qui comptent le plus de magasins alimentaires?

```{r, include=FALSE}
alim42 %>% 
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim))
```

```{r echo=FALSE}
morecommerces <- alim42 %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim)) %>%
  head(3)
```
Les trois communes comptant le plus de commerces alimentaires sont : `r morecommerces$libelleCommuneEtablissement`

Pour les communes qui ne comptent qu‚Äôun seul commerce ‚Äúalimentaire‚Äù, de quel type est-il, le plus fr√©quemment?
```{r echo=FALSE}
onlyonecommerce <- group_by(alim42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  filter(nb_commerces_alim==1)
```

Les communes ne comptant qu'un seul commerce "alimentaire" sont au nombre de `r length(onlyonecommerce$codeCommuneEtablissement)`. Avec en d√©tail :
`r onlyonecommerce$libelleCommuneEtablissement`

```{r echo=FALSE}
typeonecommerce <- filter(alim42, codeCommuneEtablissement 
                          %in% onlyonecommerce$codeCommuneEtablissement) %>%
  group_by(Type) %>%
  summarise(nb_types=n()) %>%
  arrange(desc(nb_types)) %>%
  filter(nb_types == max(nb_types))
```
Lorsqu'il y a un seul commerce alimentaire dans une commune, celui-ci est de type `r typeonecommerce$Type`.

Quelles communes de plus de 100 commerces comptent au moins 10 commerces de type ‚Äúviande‚Äù?
```{r}
data42 <- inner_join(data42, APE_Type, by="Code")
```

```{r}
morethan100commerces <- group_by(data42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces=n())
morethan100commerces <- filter(morethan100commerces, nb_commerces>=100)
```

Les communes de plus de 100 commerces sont `r morethan100commerces$libelleCommuneEtablissement`

```{r}
morethan10viandes <- filter(data42, TypeAbreg=='viande') %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_viande=n())
morethan10viandes <- filter(morethan10viandes, nb_commerces_viande>=10)
```

Les communes qui ont plus de 10 commerces de type 'viande' sont `r morethan10viandes$libelleCommuneEtablissement`

On retrouve les `r length(morethan10viandes$codeCommuneEtablissement)` communes ayant plus de 10 commerces de type 'viande' dans les villes ayant plus de 100 commerces. On a donc la r√©ponse. Mais pour s'assurer, on peut r√©aliser une jointure entre les 2 tableaux :

```{r}
more100commerces10viandes <- left_join(morethan10viandes, morethan100commerces, 
                                       by=c("codeCommuneEtablissement", "libelleCommuneEtablissement"))
```

On retrouve le m√™me r√©sultat : `r more100commerces10viandes$libelleCommuneEtablissement`

# Rapport, statistiques descriptives
A ce stade, votre script commence √† √™tre un peu long et (peut-√™tre) un peu d√©sordonn√©‚Ä¶ Ne serait-ce pas plus agr√©able de continuer votre projet sous la forme d‚Äôun rapport Rmarkdown? (Ne r√©pondez pas √† cette question, elle est rh√©torique‚Ä¶).

Cr√©ez un document ____.Rmd, structurez-le avec quelques titres, et r√©partissez les diff√©rents morceaux de code de votre script de mani√®re pertinente dans diff√©rents chunks.
Vous pouvez maintenant r√©diger des paragraphes en y int√©grant des √©l√©ments de r√©ponses aux questions pos√©es pr√©c√©demment. R√©digez un petit paragraphe pour nommer les 3 communes qui comptent le plus d‚Äôentreprises (exercice pr√©c√©dent) en utilisant l‚Äôinsertion d‚Äô‚Äúinline chunks‚Äù.

Les 3 communes qui ocmptent le plus d'entreprises sont `r morecommerces$libelleCommuneEtablissement`.

A partir de maintenant, votre document de travail sera un document`___.Rmd‚Äô et non le script que vous avez cr√©√© initialement‚Ä¶

# Programmation: automatisation pour plusieurs d√©partements
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_prog.png")
```

## Fonction
Pour obtenir la table alim42, vous avez r√©alis√© un certain nombre d‚Äôop√©rations. On voudrait r√©aliser l‚Äôensemble de ces op√©rations pour les 5 d√©partements suivants:

- l‚ÄôAin (01)
- l‚ÄôIs√®re (38)
- la Loire (42)
- la Haute-Loire (43)
- le Rh√¥ne (69)

R√©utilisez les commandes que vous avez mises au point sur data42 pour √©crire une fonction get_clean_data() qui r√©alisera l‚Äôensemble de ces op√©rations sur le d√©partement de votre choix. L‚Äôinput correspondra √† un num√©ro de d√©partement (c‚Äôest-√†-dire que vous pourrez utiliser la fonction en faisant, par exemple get_clean_data("01")).

üí≠ Pour lire le fichier, il faudra indiquer son chemin‚Ä¶ Pensez √† r√©utiliser ce que vous venez d‚Äôapprendre sur les cha√Ænes de caract√®res pour reformer le chemin du fichier que vous int√©resse √† partir du num√©ro de d√©partement‚Ä¶

Certaines cha√Ænes de caract√®re sont interpr√©t√©es comme des cha√Ænes de caract√®re pour certains jeux de donn√©es (par exemple pour les codes postaux de l‚ÄôAin, √† cause du ‚Äú0‚Äù en d√©but de cha√Æne) tandis qu‚Äôelle est interpr√©t√©e comme un num√©rique pour les autres jeux de donn√©es. Faites en sorte que votre fonction transforme bien cette variable pour qu‚Äôelles soient toujours de classe ‚Äúcharacter‚Äù en sortie (conversion par as.character()‚Ä¶).

```{r}
library(purrr)
departements <- list("01", "38", "42", "43", "69")
```

```{r}
get_clean_data <- function(dept) {
  dept <- as.character(dept)
  print(dept)
  # Read CSV file for dept
  filename <- "data/geo_siret_XX.csv"
  filename <- str_replace(filename, "X{2}", dept)
  print(filename)
  data <- read_csv(filename)
  data <- mutate(data, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
  alim <- filter(data, Code %in% code_alim)
  alim <- left_join(alim, APE_Type, by="Code")
  
  return(alim)
}
```

```{r}
convert_to_str <- function(param) {
  str_param = as.character(param)
  return(str_param)
}
```

## It√©ration

Appelez cette fonction de mani√®re it√©rative pour chacun des d√©partements cit√©s ci-dessus. Vous pouvez pour ce faire soit √©crire une boucle for, soit utiliser la fonction map() du package purrr.

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  commercesRA <- departements %>% map(get_clean_data)
  #commercesRA <- mutate(commercesRA, codePostalEtablissement=convert_to_str(codePostalEtablissement))
} else {
  alimRA_entr <- read_csv("data/alimRA_entr.csv")
}
```

A partir des 5 jeux de donn√©es obtenus vous cr√©erez un seul et m√™me jeu de donn√©es alimRA_entr (donn√©es pour l‚Äôancienne r√©gion Rh√¥ne-Alpes, o√π 1 ligne=1 entreprise).

üóØ Vous pourrez si vous le souhaitez vous servir de la commande do.call("rbind",...) ou bind_rows().

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  #alimRA_entr <- bind_rows(commercesRA)
  alimRA_entr <- do.call("rbind", commercesRA)
}
```

Rajoutez une variable departement (correspondant au num√©ro de d√©partement) √† votre jeu de donn√©es alimRA_entr. Peut-√™tre par des manipulations sur le code postal?‚Ä¶

```{r}
if (!file.exists("data/alimRA_entr.csv")) {
  alimRA_entr <- mutate(alimRA_entr, codePostalEtablissement= as.character(codePostalEtablissement))
  #alimRA_entr <- mutate(alimRA_entr, codePostalEtablissement=gsub("^([0-9]{1,4})", "0\\1", as.character(codePostalEtablissement)))
  alimRA_entr <- mutate(alimRA_entr, departement=str_extract(codePostalEtablissement, "^.{2}"))
}
```

## If et √©criture de fichier

Vous avez d√ª remarquer que l‚Äôex√©cution de l‚Äô√©tape pr√©c√©dente prenait un peu de temps car les 5 fichiers geo-sirene lus sont tr√®s volumineux‚Ä¶ En revanche la table alimRA_entr est de taille beaucoup plus raisonnable. Or, nous n‚Äôaurons besoin que de cette table pour la suite du projet. Pour √©viter d‚Äôex√©cuter cette √©tape chronophage √† chaque fois que vous travaillerez sur ce projet:

- exportez alimRA_entr dans un fichier alimRA_entr.csv.
- entourez la boucle for d‚Äôune structure conditionnelle if de sorte que la boucle ne soit ex√©cut√©e que si le fichier alimRA_entr.csv n‚Äôexiste pas (voir fonction file.exists()‚Ä¶)
- √©crivez √† la suite la commande qui servira √† lire alimRA_entr.csv √† chaque ‚Äútricotage‚Äù de votre rapport Rmarkdown.

```{r}
write_csv(alimRA_entr, "data/alimRA_entr.csv")
alimRA_entr <- read_csv("data/alimRA_entr.csv")
#alimRA_entr <- map(., mutate(., codePostalEtablissement=convert_code_postal(codePostalEtablissement)))
```

# R√©sum√© par commune et type de commerce
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_resume.png")
```

## Agr√©gation des donn√©es par commune et type de commerce
Agr√©gez la table alimRA_entr par commune et type de commerce, pour cr√©er une table alimRA_typeCom (o√π une ligne correspondra √† un type de commerce pour une commune):

```{r eval=FALSE, include=FALSE}
get_nb_commerces_by_commune <- function(df) {
  df <- group_by(df, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
    summarise(nb_commerces=n())
  return(df$nb_commerces)
}
get_nb_commerces_by_type_by_commune <- function(df) {
  
  
  return(alim)
}
get_proportion_type_in_commune {
<- function(df)   
}return(0)
```

```{r}
alimRA_Com <- group_by(alimRA_entr, codeCommuneEtablissement, libelleCommuneEtablissement)%>%
  summarise(nInCom=n())
alimRA_type <- group_by(alimRA_entr, codeCommuneEtablissement, libelleCommuneEtablissement, TypeAbreg)%>%
  summarise(nInTypeCom=n()) %>%
  mutate(propInTypeCom = round(nInTypeCom / sum(nInTypeCom)*100, digits = 2))
```

- une variable nInCom correspondant au nombre de commerces par commune
- une variable nInTypeCom correspondant au nombre de commerces par type et commune
- une variable propInTypeCom correspondant √† la proportion d‚Äôun type de commerce dans une commune

```{r}
alimRA_typeCom <- left_join(alimRA_Com, alimRA_type, 
                                       by=c("codeCommuneEtablissement", "libelleCommuneEtablissement"))
```

Quelles communes comptant plus de 100 commerces comptes au moins 5% de commerces de type ‚Äúviande‚Äù?
```{r}
communes_15pct_bar <- filter(alimRA_typeCom, TypeAbreg=='bar' & nInCom >= 100 & propInTypeCom >= 15)
communes_5pct_viande <- filter(alimRA_typeCom, TypeAbreg=='viande' & nInCom >= 100 & propInTypeCom >= 5)
```

Les communes comptant plus de 100 commerces, dont les commerces de type 'bar' repr√©sentent au moins 15% des commerces sont `r communes_15pct_bar$libelleCommuneEtablissement`.

Les communes comptant plus de 100 commerces, dont les commerces de type 'viande' repr√©sentent au moins 5% des commerces sont `r communes_5pct_viande$libelleCommuneEtablissement`.

## Graphique
R√©alisez un graphique montrant les proportions des diff√©rents types de commerces pour LYON 4EME et LYON 8EME.

```{r}
lyon4 <- filter(alimRA_typeCom, codeCommuneEtablissement == 69384)
propLyon4 <- ggplot(lyon4, aes(x="", y=propInTypeCom, fill=TypeAbreg))+
  geom_bar(width = 2, stat = "identity", position = "dodge") + geom_text(aes(label=paste("\n", propInTypeCom, "%")), position = position_dodge(width = 2)) +
  ggtitle("R√©partition des types de commerces √† Lyon 4√®me") + scale_fill_discrete(name= "Type de commerce", labels=c("Autre", "Bar", "Boulangerie-P√¢tisserie", "Fruits et l√©gumes", "Magasin sp√©cialis√©", "Restaurant", "Supermarch√©", "Traiteur", "Boucherie")) + theme_minimal() + labs(x="", y="R√©partition (%)")
propLyon4
```

```{r}
lyon8 <- filter(alimRA_typeCom, codeCommuneEtablissement == 69388)
propLyon8 <- ggplot(lyon8, aes(x="", y=propInTypeCom, fill=TypeAbreg)) +
  geom_bar(width = 5, stat = "identity", position = "dodge") + geom_text(aes(label=paste("\n",propInTypeCom, "%")),
                                                     position = position_dodge(width = 5)) + 
  ggtitle("R√©partition des types de commerces √† Lyon 8√®me") + scale_fill_discrete(name= "Type de commerce", labels=c("Autre", "Bar", "Boulangerie-P√¢tisserie", "Fruits et l√©gumes", "Magasin sp√©cialis√©", "Restaurant", "Supermarch√©", "Traiteur", "Boucherie")) + theme_minimal() + labs(x="", y="R√©partition (%)")
propLyon8
```

# Evolution dans le temps des cr√©ations d‚Äôentreprise
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_temps.png")
```

## Manipuler des dates avec lubridate
Nous allons nous int√©resser aux dates de cr√©ation des entreprises de notre base alimRA_entr (variable dateCreationEtablissement).

üóØ Pour le moment, dateCreationEtablissement est consid√©r√© comme une variable de type ‚Äúcha√Æne de caract√®res‚Äù. Pour faire comprendre √† R qu‚Äôil s‚Äôagit en r√©alit√© d‚Äôune date (et lui faire comprendre comment elle est mise en forme) nous allons faire appel au package lubridate.

- Installez et chargez le package lubridate.
```{r}
library(lubridate)
```

- Transformez le tableau alimRA_entr en modifiant la classe de dateCreationEtablissement √† l‚Äôaide d‚Äôune fonction de lubridate.
```{r}
alimRA_entr <- mutate(alimRA_entr, dateCreationEtablissement = ymd(dateCreationEtablissement))
```

- Ajoutez une variable annee au tableau alimRA_entr √† l‚Äôaide, √† nouveau, d‚Äôune des fonctions de lubridate.
```{r}
alimRA_entr <- mutate(alimRA_entr, annee = year(dateCreationEtablissement))
```

## R√©sum√©, filtre
- Cr√©ez une table alimRA_typeAn qui recense le nombre d‚Äôentreprises par ann√©e (nInAn), et par type*ann√©e (nInTypeAn).
```{r}
alimRA_annee <- group_by(alimRA_entr, annee)%>%
  summarise(nInAn=n())
alimRA_type_annee <- group_by(alimRA_entr, annee, TypeAbreg)%>%
  summarise(nInTypeAn=n())
alimRA_typeAn <- left_join(alimRA_type_annee, alimRA_annee, 
                                       by=c("annee"))
```

- Filtrez les donn√©es de alimRA_typeAn pour ne garder que les entreprises dont la cr√©ation correspond aux ann√©es >=1970.
```{r}
alimRA_ap1970 <- filter(alimRA_typeAn, annee >= 1970)
```

## Graphiques: √©volution du nombre d‚Äôentreprises au cours du temps
- Installez et chargez le package ggplot2
- R√©alisez un graphique repr√©sentant l‚Äô√©volution des proportions d‚Äôentreprises (par type) par ann√©e.
```{r}
alimRA_ap1970 <- mutate(alimRA_ap1970, propTypeAn = as.numeric(sprintf("%0.2f", nInTypeAn / nInAn * 100)))
alimRA_ap1970 <- filter(alimRA_ap1970, annee!=2020)
prop_alimRA_ap1970 <- ggplot(alimRA_ap1970, aes(x=annee, y=propTypeAn, color=TypeAbreg, fill = TypeAbreg)) 
prop_alimRA_ap1970 +
  geom_line(size = 1) + 
  ggtitle("Evolution des proportions d'entreprises par type par ann√©e") + scale_color_discrete(name = "Type de commerce", labels=c("Autre", "Bar", "Boulangerie-P√¢tisserie", "Fruits et l√©gumes", "Produits laitiers", "Magasin sp√©cialis√©", "Poissonnerie", "Restaurant", "Supermarch√©", "Traiteur", "Boucherie")) + labs(x="Ann√©e", y="Taux d'entreprise")+ theme_minimal()
```
```{r fig.height=10}
labels = c(autres = "Autre", bar = "Bar", boulPatiss = "Boulangerie-P√¢tisserie", fruitsleg = "Fruits et l√©gumes", laitier = "Produits laitiers", magasinSpecialise = "Magasin sp√©cialis√©", poisson = "Poissonnerie", restau = "Restaurant", supermarche = "Supermarch√©", traiteur = "Traiteur", viande = "Boucherie")
prop_alimRA_ap1970 + guides(fill = "none") + geom_area(show.legend = FALSE) + facet_wrap(.~TypeAbreg, ncol=1,  scales = "fixed", labeller = labeller(TypeAbreg=labels)) + theme_bw()
```

- R√©alisez ce m√™me graphique, mais en repr√©sentant le nombre de cr√©ations d‚Äôentreprises par ann√©e et par type, pour les 5 types comptant le plus de cr√©ations d‚Äôentreprises (au total).
```{r}
alimRA_5types <- group_by(alimRA_ap1970, TypeAbreg) %>% summarise(nb_creations = sum(nInTypeAn)) %>%
  arrange(desc(nb_creations)) %>% head(5)
crea_alimRA_5types <- filter(alimRA_ap1970, TypeAbreg %in% alimRA_5types$TypeAbreg)
nb_creations_alimRA_ap1970 <- ggplot(crea_alimRA_5types, aes(x=annee, y=nInTypeAn, color=TypeAbreg, fill = TypeAbreg)) 
nb_creations_alimRA_ap1970 +
  geom_line(size = 1) + 
  ggtitle("Nombre de cr√©ations d'entreprises par type par ann√©e") + scale_color_discrete(name = "Type de commerce", labels = c("Bar", "Boulangerie-P√¢tisserie", "Magasin sp√©cialis√©", "Restaurant", "Supermarch√©")) + labs(x="Ann√©e", y="Nombre de cr√©ations d'entreprises")+ theme_minimal()
```
