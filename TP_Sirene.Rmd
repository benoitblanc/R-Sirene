---
title: "TP_Sirene"
author: "Beno√Æt Blanc"
date: "10/10/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

# Mise en place

```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow.png")
```

## Installations, t√©l√©chargements, premiers tests sur le d√©partement 42
T√©l√©chargez les donn√©es du d√©partement 42, geo_siret_42.csv dans ce r√©pertoire et d√©zippez le dossier sur votre machine.

T√©l√©chargez la table qui renseigne les codes correspondant √† l‚ÄôActivit√© Principale de l‚ÄôEtablissement (APE)APE_Type.csv

```{r}
library(dplyr)
library(readr)
```

## Lecture de tableaux de donn√©es
Depuis RStudio, cr√©ez un projet qui comprendra l‚Äôensemble des donn√©es et documents n√©cessaires √† r√©aliser l‚Äôensemble des traitements qui vous seront demand√©s pour ce TP.

Cr√©ez le data.frame data42 en lisant la table geo-siret_42.csv.
```{r, include=TRUE}
data42 <- read.csv("data/geo_siret_42.csv")
```
Cr√©ez l‚Äôobjet APE_Type en lisant le fichier relatif aux codes d‚ÄôAPE.
```{r, include=TRUE}
APE_Type <- read.csv("data/APE_Type.csv")
```

## Code et types d‚Äôactivit√©s => commerces alimentaires
```{r}
library(stringr)
```
Combien d‚Äôentreprises ont un nom (enseigne1Etablissement) qui comprend le terme ‚ÄúBOULANGERIE‚Äù?
```{r}
boulangeries <- filter(data42, str_detect(enseigne1Etablissement, "BOULANGERIE"))
```
Il y a `r summarise(boulangeries, n())` entreprises qui comprennent le terme "BOULANGERIE" dans leur nom.

Ajoutez une variable Code √† votre table en ne conservant que les quatre premiers caract√®res de la variable activitePrincipaleEtablissement (cela correspond √† un pattern ‚Äú^‚Ä¶.‚Äù, √† savoir le d√©but de cha√Æne de caract√®re suivi de quatre caract√®res quelconques -cf ce billet de blog sur les expressions r√©guli√®res-).

```{r}
data42 <- mutate(data42, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
```

Filtrez les lignes de data42 pour ne retenir que celles pour lesquelles l‚ÄôAPE correspond aux commerces ‚Äúalimentaires‚Äù -alimentation, boisson, restaurant, bar- (voir la liste contenue dans le fichier APE_Type).

Stockez le r√©sultat de ces op√©rations dans un objet alim42.

```{r, echo=FALSE, include=FALSE}
print(APE_Type)
```

```{r}
alim42 <- filter(data42, Code=="47.1" | Code=="47.2" | Code=="56.1" | Code=="56.2" | Code=="56.3")
```

R√©alisez une jointure entre data42_alim (variable codeAPE) et APE_Type (variable Code), de mani√®re √† compl√©ter alim42 avec les types de commerces (variables Type et TypeAbreg).

```{r}
alim42 <- left_join(alim42, APE_Type, by="Code")
```

## R√©sum√©, classement
Quelles sont les 3 communes de votre base de donn√©es qui comptent le plus de magasins alimentaires?

```{r, include=FALSE}
alim42 %>% 
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim))
```
Les trois communes comptant le plus de commerces alimentaires sont 
```{r}
alim42 %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  arrange(desc(nb_commerces_alim)) %>%
  head(3)
```

Pour les communes qui ne comptent qu‚Äôun seul commerce ‚Äúalimentaire‚Äù, de quel type est-il, le plus fr√©quemment?
```{r}
onlyonecommerce <- group_by(alim42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_alim=n()) %>%
  filter(nb_commerces_alim==1)
```

Les communes ne comptant qu'un seul commerce "alimentaire" sont au nombre de `r length(onlyonecommerce$codeCommuneEtablissement)`. Avec en d√©tail :
`r onlyonecommerce$libelleCommuneEtablissement`

```{r}
typeonecommerce <- filter(alim42, codeCommuneEtablissement 
                          %in% onlyonecommerce$codeCommuneEtablissement) %>%
  group_by(Type) %>%
  summarise(nb_types=n()) %>%
  arrange(desc(nb_types)) %>%
  filter(nb_types == max(nb_types))
```
Lorsqu'il y a un seul commerce alimentaire dans une commune, celui-ci est de type `r typeonecommerce$Type`.

Quelles communes de plus de 100 commerces comptent au moins 10 commerces de type ‚Äúviande‚Äù?
```{r}
data42 <- inner_join(data42, APE_Type, by="Code")
```

```{r}
morethan100commerces <- group_by(data42, codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces=n())
morethan100commerces <- filter(morethan100commerces, nb_commerces>=100)
```

Les communes de plus de 100 commerces sont `r morethan100commerces$libelleCommuneEtablissement`

```{r}
morethan10viandes <- filter(data42, TypeAbreg=='viande') %>%
  group_by(codeCommuneEtablissement, libelleCommuneEtablissement) %>%
  summarise(nb_commerces_viande=n())
morethan10viandes <- filter(morethan10viandes, nb_commerces_viande>=10)
```

Les communes qui ont plus de 10 commerces de type 'viande' sont `r morethan10viandes$libelleCommuneEtablissement`

On retrouve les `r length(morethan10viandes$codeCommuneEtablissement)` communes ayant plus de 10 commerces de type 'viande' dans les villes ayant plus de 100 commerces. On a donc la r√©ponse. Mais pour s'assurer, on peut r√©aliser une jointure entre les 2 tableaux :

```{r}
more100commerces10viandes <- left_join(morethan10viandes, morethan100commerces, 
                                       by=c("codeCommuneEtablissement", "libelleCommuneEtablissement"))
```

On retrouve le m√™me r√©sultat : `r more100commerces10viandes$libelleCommuneEtablissement`

# Rapport, statistiques descriptives
A ce stade, votre script commence √† √™tre un peu long et (peut-√™tre) un peu d√©sordonn√©‚Ä¶ Ne serait-ce pas plus agr√©able de continuer votre projet sous la forme d‚Äôun rapport Rmarkdown? (Ne r√©pondez pas √† cette question, elle est rh√©torique‚Ä¶).

Cr√©ez un document ____.Rmd, structurez-le avec quelques titres, et r√©partissez les diff√©rents morceaux de code de votre script de mani√®re pertinente dans diff√©rents chunks.
Vous pouvez maintenant r√©diger des paragraphes en y int√©grant des √©l√©ments de r√©ponses aux questions pos√©es pr√©c√©demment. R√©digez un petit paragraphe pour nommer les 3 communes qui comptent le plus d‚Äôentreprises (exercice pr√©c√©dent) en utilisant l‚Äôinsertion d‚Äô‚Äúinline chunks‚Äù.
A partir de maintenant, votre document de travail sera un document`___.Rmd‚Äô et non le script que vous avez cr√©√© initialement‚Ä¶

# Programmation: automatisation pour plusieurs d√©partements
```{r, include=TRUE, echo=FALSE}
knitr::include_graphics("workflow_prog.png")
```

## Fonction
Pour obtenir la table alim42, vous avez r√©alis√© un certain nombre d‚Äôop√©rations. On voudrait r√©aliser l‚Äôensemble de ces op√©rations pour les 5 d√©partements suivants:

- l‚ÄôAin (01)
- l‚ÄôIs√®re (38)
- la Loire (42)
- la Haute-Loire (43)
- le Rh√¥ne (69)

R√©utilisez les commandes que vous avez mises au point sur data42 pour √©crire une fonction get_clean_data() qui r√©alisera l‚Äôensemble de ces op√©rations sur le d√©partement de votre choix. L‚Äôinput correspondra √† un num√©ro de d√©partement (c‚Äôest-√†-dire que vous pourrez utiliser la fonction en faisant, par exemple get_clean_data("01")).

üí≠ Pour lire le fichier, il faudra indiquer son chemin‚Ä¶ Pensez √† r√©utiliser ce que vous venez d‚Äôapprendre sur les cha√Ænes de caract√®res pour reformer le chemin du fichier que vous int√©resse √† partir du num√©ro de d√©partement‚Ä¶

Certaines cha√Ænes de caract√®re sont interpr√©t√©es comme des cha√Ænes de caract√®re pour certains jeux de donn√©es (par exemple pour les codes postaux de l‚ÄôAin, √† cause du ‚Äú0‚Äù en d√©but de cha√Æne) tandis qu‚Äôelle est interpr√©t√©e comme un num√©rique pour les autres jeux de donn√©es. Faites en sorte que votre fonction transforme bien cette variable pour qu‚Äôelles soient toujours de classe ‚Äúcharacter‚Äù en sortie (conversion par as.character()‚Ä¶).

```{r}
library(purrr)
```

```{r}
get_clean_data <- function(dept) {
  dept <- as.character(dept)
  print(dept)
  # Read CSV file for dept
  filename <- "data/geo_siret_XX.csv"
  filename <- str_replace(filename, "X{2}", dept)
  print(filename)
  data <- read.csv(filename)
  data <- mutate(data, Code=as.numeric(str_extract(activitePrincipaleEtablissement, "^....")))
  alim <- filter(data, Code=="47.1" | Code=="47.2" | Code=="56.1" | Code=="56.2" | Code=="56.3")
  alim <- left_join(alim, APE_Type, by="Code")
  
  return(alim)
}
```

## It√©ration

```{r}
departements <- list("01", "38", "42", "43", "69")
commercesRA <- map(departements, get_clean_data)
```

```{r}
#alimRA_entr <- bind_rows(commercesRA)
alimRA_entr <- do.call("rbind", commercesRA)
alimRA_entr <- mutate(alimRA_entr, codePostalEtablissement=gsub("^([0-9]{1,4})($)", "0\\1\\2",codePostalEtablissement))
alimRA_entr <- mutate(alimRA_entr, departement=str_subset(codePostalEtablissement, "^[0-9]{2}"))
```